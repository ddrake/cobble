<?php
defined('C5_EXECUTE') or die(_("Access Denied."));

class Cobble extends Object
{

    // refresh the Cobble tables.
    function refresh()
    {
        Loader::model('cobble_page_theme', 'cobble');
        $cpt = new CobblePageTheme();
        $cpt->refresh();

        Loader::model('cobble_page_type', 'cobble');
        $cct = new CobblePageType();
        $cct->refresh();

        Loader::model('cobble_page', 'cobble');
        $cp = new CobblePage();
        $cp->refresh();

        Loader::model('cobble_template_area', 'cobble');
        $cta = new CobbleTemplateArea();
        $cta->refresh();

        Loader::model('cobble_area', 'cobble');
        $ca = new CobbleArea();
        $ca->refresh();
    }

    function QueryNames_info()
    {
        $rslt = array();
        foreach ($this->queries_info as $k => $v) {
            $rslt[$k] = $v['name'];
        }

        return $rslt;
    }

    function QueryNames_diag()
    {
        $rslt = array();
        foreach ($this->queries_diag as $k => $v) {
            $rslt[$k] = $v['name'];
        }

        return $rslt;
    }

    function QueryColHeads_info($query)
    {
        $inf = $this->queries_info[$query];

        return $inf['colheads'];
    }

    function QueryColHeads_diag($query)
    {
        $inf = $this->queries_diag[$query];

        return $inf['colheads'];
    }

    function QueryName_info($query)
    {
        $inf = $this->queries_info[$query];

        return $inf['name'];
    }

    function QueryName_diag($query)
    {
        $inf = $this->queries_diag[$query];

        return $inf['name'];
    }

    function QueryDescription_info($query)
    {
        $inf = $this->queries_info[$query];

        return $inf['description'];
    }

    function QueryDescription_diag($query)
    {
        $inf = $this->queries_diag[$query];

        return $inf['description'];
    }

    function GetQueryResult($query)
    {
        return $this->$query();
    }

    /****************************************************/
    /*               QUERY LISTS                        */
    /****************************************************/
    public $queries_info = array(
        'theme_view' => array(
            'name' => 'Themes',
            'description' => "Shows information about all installed themes and all theme directories in the file system, whether installed or not. <ul><li>'Directory' is simply the directory in the file system containing the theme.  If this shows: 'DIRECTORY MISSING!', it means that the theme directory has been deleted, but the theme hasn't been uninstalled.</li><li>'Overridden' indicates that the theme directory will be overridden by one with higher precedence.</li><li>'Site Theme' indicates that this theme is assigned to the home page and hence is the default theme for the site.  The view.php wrapper in this theme will be used to wrap single page templates located in single_pages directories unless they specify a theme in config/site_theme_paths.php or concrete/config/theme_paths.php</li></ul>",
            'colheads' => array(
                'Theme',
                'Theme Handle',
                'Description',
                'Package Handle',
                'Directory',
                'Installed?',
                'Overridden?',
                'Site Theme?'
            )
        ),
        'page_type_view' => array(
            'name' => 'Page Types',
            'description' => "Shows the template file or files that will be used to render a page with a given page type and theme. All possible combinations of themes and page types are listed. <ul><li>'File Prefix' is just the prefix of the template file. It's shown here for easy comparison with the page type handle.<li>'Wrapper Path' is used only by theme-independent page types to wrap the content generated by the the template.</li><li>'SP Handle Conflict?' indicates a page type template that has the same name as a single page which does not have its theme overridden in site_theme_paths.php or concrete/theme_paths.php.  This can produce a conflict since single pages can be rendered by a template in the current theme with a file prefix matching the single page's handle.</li></ul>",
            'colheads' => array(
                'Theme',
                'Page Type',
                'Page Type Handle',
                'File Prefix',
                'File Path',
                'Wrapper Path',
                'Package Handle',
                'SP Handle Conflict?'
            )
        ),
        'page_view' => array(
            'name' => 'Pages',
            'description' => "Shows all pages in the sitemap as well as any unregistered single pages.<ul><li>'cID' is the collection ID for the page.  Unregistered single pages do not have a collection ID. In this case, 'USP' is displayed.</li><li>'cFilename' specifies the location of a single page within one of the single_page directories</li><li>'Handle' specifies the collection handle of the approved page revision for registered single pages.  If a template exists in the current theme with prefix matching this handle, that template will be used to render the page completly.  For unregistered single pages, the file prefix of the template is shown for reference.</li><li>'Theme From Path?' indicates that the wrapper for the  page is specified in /config/site_theme_paths.php or /concrete/config/theme_paths.php  This supercedes any other possible wrapper (such as view.php in the current theme).</li><li>'Page Defaults Template?' indicates that this 'page' is actually a Page Defaults template.</li><li>'Wrapper Missing' indicates that the single page requires a wrapper, but it cannot be found.  A possible cause might be that the current theme is missing a view.php template.</li><li>'File Missing' indicates that no template can be found for rendering the page</li></ul>",
            'colheads' => array(
                'cID',
                'cFilename',
                'Handle',
                'Page Type Handle',
                'filePath',
                'wrapperPath',
                'Single Page?',
                'Theme From Path?',
                'Page Defaults Template?',
                'Wrapper Missing?',
                'File Missing?',
                'Alias?',
                'Ext. Link?'
            )
        ),
        'area_view' => array(
            'name' => 'Areas',
            'description' => "Shows all the areas defined for each page and the location of the template that either defines the area or includes elements via \$this->inc() which define the area.  Jordan Lev's 'GlobalAreas' are also included in this list.<ul><li>'cID' is the collection ID for the page</li><li>'Area Handle' is the area handle defined in the template</li><li>'File Path' is the path to the template defining the area.</li><li>'Handle Duplicated?' indicates that the area handle was found more than once in the page's template</li><li>'Global Area?' indicates a global area defined by Jordan Lev's model. Blocks contained in these areas are editable from one location, typically the home page, but an alternate location may also be specified.</li><li>'Global Template Path' specifies the template path for global areas</li><li>'Block Count' gives a count of the blocks contained in this area.  Blocks hard-coded in templates are not included in the count.</li></ul> ",
            'colheads' => array(
                'Page Handle or Defaults Type',
                'cID',
                'Area Handle',
                'File Path',
                'Handle Duplicated?',
                'Global Area?',
                'Global Template Path',
                'Global Scrapbook',
                'Block Count'
            )
        )
    );

    public $queries_diag = array(
        'db_pages_missing_collections' => array(
            'name' => 'Database Pages Ref\'ing Non-existent Collections',
            'description' => "Lists pages defined in the application database which reference collections that no longer exist.<ul><li>'cID' is the collection ID of the page for which no collection exists.</li><li>'Page Path' is the cPath of the page.</li></ul>",
            'colheads' => array('cID', 'Page Path')
        ),
        'db_areas_missing_pages' => array(
            'name' => 'Database Areas Ref\'ing Non-existent Pages',
            'description' => "Lists areas defined in the application database which reference pages that no longer exist.<ul><li>'arID' is the area ID.</li><li>'cID' is the referenced collection ID for the non-existent page.</li></ul>",
            'colheads' => array('cID', 'Area Handle', 'arID')
        ),
        'installed_themes_missing_directories' => array(
            'name' => 'Installed themes missing directories',
            'description' => "Lists installed themes for which no directory exists in the file system.",
            'colheads' => array('Theme', 'Theme Handle', 'Description', 'Package Handle', 'Site Theme?')
        ),
        'page_types_missing_templates' => array(
            'name' => 'Page Types Missing Templates',
            'description' => "Lists page types for which no template exists in the file system.<br />Ensure that the theme directory contains a default.php template",
            'colheads' => array('Theme', 'Page Type', 'Page Type Handle', 'Package Handle')
        ),
        'theme_independent_page_types_missing_wrappers' => array(
            'name' => 'Theme-Independent Page Types Missing Wrappers',
            'description' => "Lists theme-independent page types for which no wrapper exists in the file system.<br />Ensure that every theme directory contains a view.php template",
            'colheads' => array('Page Type', 'Page Type Handle', 'Package Handle')
        ),
        'page_type_sp_conflict' => array(
            'name' => 'Page Types with Single Page Handle Conflict',
            'description' => "Lists page types whose handle matches that of a single page whose theme has not been overridden in site_theme_paths.php or concrete/theme_paths.php.  This can produce a conflict since single pages can be rendered by a template in the current theme with a file prefix matching the single page's handle.",
            'colheads' => array(
                'Theme',
                'Page Type',
                'Page Type Handle',
                'File Prefix',
                'File Path',
                'Wrapper Path',
                'Package Handle'
            )
        ),
        'unregistered_single_pages' => array(
            'name' => 'Unregistered Single Pages',
            'description' => "Lists single pages which exist in the file system, but aren't registered in the application.<br />Concrete5 v 5.4.0.5 contains five such files: install.php, upgrade.php, maintenance_mode.php, user_error.php and dashboard/mediabrowser.php.  These do not pose any problem.",
            'colheads' => array('cFilename', 'Handle', 'filePath')
        ),
        'pages_missing_file' => array(
            'name' => 'Pages Missing File',
            'description' => "Lists pages for which no template exists in the file system.<br />Concrete5 v 5.4.0.5 contains one such file: with handle 'marketplace'.  This does not pose any problem.",
            'colheads' => array('cID', 'cFilename', 'Handle', 'wrapperPath')
        ),
        'single_pages_missing_wrapper' => array(
            'name' => 'Single Pages Missing Wrapper',
            'description' => "Lists registered single pages for which no wrapper exists in the file system.",
            'colheads' => array('cID', 'cFilename', 'Handle', 'filePath')
        ),
        'blocks_missing_areas_recent' => array(
            'name' => 'Blocks Ref\'ing Areas not in Templates - Current Rev.',
            'description' => "Lists blocks in RECENT page versions which reference areas that are not found in the page's templates.  This may indicate blocks that have been orphaned by changing to a theme which does not define all referenced Area Handles.<ul><li>'cID' is the collection ID for the page.</li><li>'bID' is the block ID</li></ul>",
            'colheads' => array('Page Handle or Type', 'cID', 'Block Type Name', 'bID', 'Area Handle')
        ),
        'blocks_missing_areas_approved' => array(
            'name' => 'Blocks Ref\'ing Areas not in Templates - Approved Rev.',
            'description' => "Lists blocks in APPROVED page versions which reference areas that are not found in the page's templates.  This may indicate blocks that have been orphaned by changing to a theme which does not define all referenced Area Handles.<ul><li>'cID' is the collection ID for the page.</li><li>'bID' is the block ID</li></ul>",
            'colheads' => array('Page Handle or Type', 'cID', 'Block Type Name', 'bID', 'Area Handle')
        )
    );

    /****************************************************/
    /*               QUERIES                            */
    /****************************************************/
    // Each query here should have a corresponding element in the query list.
    function theme_view()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select cpt.ptName, cpt.ptHandle, cpt.ptDescription, cpt.pkgHandle, cpt.ptDirectory, ' .
            ' (not isnull(cpt.ptID) or cpt.isOverridden = 1) as isInstalled, cpt.isOverridden, cpt.isSiteTheme ' .
            ' from CobblePageThemes cpt ' .
            ' order by cpt.ptName ';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            extract($row);
            $row['isInstalled'] = $this->b2t($isInstalled);
            $row['isOverridden'] = $this->b2t($isOverridden);
            $row['isSiteTheme'] = $this->b2t($isSiteTheme);
            $row['ptDirectory'] = $this->null2msg($ptDirectory, 'DIRECTORY MISSING!');
            $row['pkgHandle'] = $this->null2na($pkgHandle);
            $rslt[] = $row;
        }

        return $rslt;
    }

    function page_type_view()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select cpt.ptName, ct.ctName, cct.ctHandle, cct.ctFilePrefix, cct.filePath, cct.wrapperPath, ' .
            ' cct.pkgHandle, (cct.isSinglePageHandle = 1 and cp.cHandle is not NULL and cp.isThemeFromPath = 0) as spHandleConflict ' .
            ' from (CobblePageTypes cct left join PageTypes ct on cct.ctID = ct.ctID) ' .
            ' left join CobblePageThemes cpt on cct.cblPtID = cpt.cblPtID ' .
            ' left join CobblePages cp on cct.ctHandle = cp.cHandle ' .
            ' order by ptName, ctName ';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            extract($row);
            $row['spHandleConflict'] = $this->b2t($spHandleConflict);
            $row['wrapperPath'] = $this->null2na($wrapperPath);
            $row['pkgHandle'] = $this->null2na($pkgHandle);
            $row['ptName'] = $this->null2msg($ptName, 'THEME-INDEPENDENT');
            $row['ctFilePrefix'] = $this->null2msg($ctFilePrefix, 'TEMPLATE MISSING!');
            $row['filePath'] = $this->null2msg($filePath, 'TEMPLATE MISSING!');
            $rslt[] = $row;
        }

        return $rslt;
    }

    function page_view()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select cp.cID, cp.cFilename, cp.cHandle, ct.ctHandle, cp.filePath, cp.wrapperPath, ' .
            ' cp.isSinglePage, cp.isThemeFromPath, cp.isTemplate, cp.isWrapperMissing, cp.isFileMissing, ' .
            ' p.cPointerID > 0 as isAlias, p.cPointerExternalLink is not null as isExternalLink ' .
            ' from (CobblePages cp left join PageTypes ct on cp.ctID = ct.ctID) ' .
            ' left join Pages p on cp.cID = p.cID ' .
            ' order by ISNULL(cp.cID), cp.cID';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            extract($row);
            $row['ctHandle'] = $this->ctHandleText($ctHandle, $isSinglePage, $isAlias, $isExternalLink);
            $row['cID'] = $this->null2msg($cID, 'USP');
            $row['isSinglePage'] = $this->b2t($isSinglePage);
            $row['isThemeFromPath'] = $this->b2t($isThemeFromPath);
            $row['isTemplate'] = $this->b2t($isTemplate);
            $row['isWrapperMissing'] = $this->b2t($isWrapperMissing);
            $row['isFileMissing'] = $this->b2t($isFileMissing);
            $row['isAlias'] = $this->b2t($isAlias);
            $row['isExternalLink'] = $this->b2t($isExternalLink);
            $rslt[] = $row;
        }

        return $rslt;
    }

    function ctHandleText($ctHandle, $isSinglePage, $isAlias, $isExternalLink)
    {
        if (empty($ctHandle)) {
            if (!empty($isExternalLink)) {
                $rslt = "N/A (ext. link)";
            } else {
                if (!empty($isAlias)) {
                    $rslt = "N/A (alias)";
                } else {
                    if (!empty($isSinglePage)) {
                        $rslt = "N/A (single page)";
                    } else {
                        $rslt = "N/A";
                    }
                }
            }
        } else {
            $rslt = $ctHandle;
        }

        return $rslt;
    }

    function area_view()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select cp.cHandle, ca.cID, ca.arHandle, cta.filePath, ' .
            ' ca.isHandleDuplicated, cta.isGlobal, ' .
            ' cta.globalTemplatePath, ca.isGlobalScrapbook, ct.ctName ' .
            ' from ((CobbleAreas ca left join CobblePages cp on ca.cblCID = cp.cblCID) ' .
            ' left join CobbleTemplateAreas cta on ca.cblTaID = cta.cblTaID) ' .
            ' left join PageTypes ct on cp.ctID = ct.ctID ' .
            ' where  (ca.cID is null or cp.cID) is not null ' .
            ' and (isGlobalScrapbook or ca.cblTaID is not null) ' .
            ' order by cID, arHandle';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            extract($row);
            $row['isHandleDuplicated'] = $this->b2t($isHandleDuplicated);
            $row['isGlobal'] = $this->b2t($isGlobal);
            $row['isGlobalScrapbook'] = $this->b2t($isGlobalScrapbook);
            $row['cID'] = $this->null2na($cID);
            $row['cHandle'] = $this->MergedPageHandle($cHandle, $ctName);
            unset($row['ctName']);
            // now get the block count
            if ($isGlobalScrapbook == 1) {
                $v1 = array($row['arHandle'], $this->GlobalScrapbookCID());
                $q1 = 'select count(*) ' .
                    ' from CollectionVersionBlocks cvb ' .
                    ' where cvb.cvID in (select max(cv.cvID) from CollectionVersions cv where cv.cID = cvb.cID)' .
                    ' and cvb.arHandle = ? ' .
                    ' and cvb.cID = ? ';
                $row['filePath'] = 'N/A (Global/Shared Scrapbook)';
            } else {
                $v1 = array($row['arHandle'], $cID);
                $q1 = 'select count(*) ' .
                    ' from CollectionVersionBlocks cvb ' .
                    ' where cvb.cvID in (select max(cv.cvID) from CollectionVersions cv where cv.cID = cvb.cID)' .
                    ' and cvb.arHandle = ? ' .
                    ' and cvb.cID = ? ';
            }
            $bCount = $db->GetOne($q1, $v1);
            // add this to the array
            $row['bCount'] = $bCount;

            $rslt[] = $row;
        }

        return $this->SortResultsByHandle($rslt);
    }

    function SortResultsByHandle($ar)
    {
        $tmp = Array();
        foreach ($ar as &$ma) {
            $tmp[] = &$ma["cHandle"];
        }
        array_multisort($tmp, $ar);

        return $ar;
    }

    function MergedPageHandle($cHandle, $ctName)
    {
        if (empty($cHandle)) {
            if (empty($ctName)) {
                return "N/A";
            } else {
                return "PG. DEF. - $ctName";
            }
        } else {
            return $cHandle;
        }

    }

    function GlobalScrapbookCID()
    {
        $db = Loader::db();
        $v = array('scrapbook');
        $q = 'select cID from Collections where cHandle = ?';
        $rslt = $db->GetOne($q, $v);

        return (empty($rslt) ? 0 : $rslt);
    }

    function blocks_missing_areas_recent()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select distinct cp.cHandle, cvb.cID, bt.btName, b.bID, cvb.arHandle, ct.ctName ' .
            ' from (((((CollectionVersionBlocks cvb inner join Blocks b on cvb.bID = b.bID) ' .
            ' inner join BlockTypes bt on b.btID = bt.btID) ' .
            ' left join CobblePages cp on cvb.cID = cp.cID) ' .
            ' left join PageTypes ct on cp.ctID = ct.ctID) ' .
            ' left join Areas a on cvb.arHandle collate utf8_general_ci = a.arHandle collate utf8_general_ci and cvb.cID = a.cID) ' .
            ' left join CobbleAreas ca on a.arID = ca.arID ' .
            ' where cvb.cvID in (select max(cv.cvID) from CollectionVersions cv where cv.cID = cvb.cID) ' .
            ' and ca.cblTaID is null ' .
            ' and (ca.isGlobalScrapbook = 0 or ca.isGlobalScrapbook is null) ' .
            ' order by cHandle, arHandle, bID ';

        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            extract($row);
            $row['cHandle'] = $this->MergedPageHandle($cHandle, $ctName);
            unset($row['ctName']);
            $rslt[] = $row;
        }

        return $rslt;
    }

    function blocks_missing_areas_approved()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select distinct cp.cHandle, cvb.cID, bt.btName, b.bID, cvb.arHandle, ct.ctName  ' .
            ' from ((((((CollectionVersionBlocks cvb inner join Blocks b on cvb.bID = b.bID) ' .
            ' inner join BlockTypes bt on b.btID = bt.btID) ' .
            ' inner join CollectionVersions cv on cvb.cID = cv.cID and cvb.cvID = cv.cvID) ' .
            ' left join CobblePages cp on cvb.cID = cp.cID) ' .
            ' left join PageTypes ct on cp.ctID = ct.ctID) ' .
            ' left join Areas a on cvb.arHandle collate utf8_general_ci = a.arHandle collate utf8_general_ci and cvb.cID = a.cID) ' .
            ' left join CobbleAreas ca on a.arID = ca.arID ' .
            ' where cv.cvIsApproved = 1' .
            ' and ca.cblTaID is null ' .
            ' and (ca.isGlobalScrapbook = 0 or ca.isGlobalScrapbook is null) ' .
            ' order by cHandle, arHandle, bID ';

        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            extract($row);
            $row['cHandle'] = $this->MergedPageHandle($cHandle, $ctName);
            unset($row['ctName']);
            $rslt[] = $row;
        }

        return $rslt;
    }

    function db_areas_missing_pages()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select ar.cID, ar.arHandle, ar.arID ' .
            ' from Areas ar left join Pages p on ar.cID = p.cID where p.cID is null' .
            ' order by cID, arHandle';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            $rslt[] = $row;
        }

        return $rslt;
    }

    function db_pages_missing_collections()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select p.cID, pp.cPath from (Pages p left join Collections c on p.cID = c.cID) ' .
            ' left join PagePaths pp on p.cID = pp.cID ' .
            ' where c.cID is null ' .
            ' order by p.cID';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            $rslt[] = $row;
        }

        return $rslt;
    }
    // Note: There is a special collection with cHandle like 'uID = 1' for each user
    // these collections are not associated with pages.  Not sure, maybe user profile info...
    function db_collections_missing_pages()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select c.cID, c.cHandle from Collections c left join Pages p on c.cID = p.cID ' .
            ' where p.cID is null ' .
            ' order by c.cID';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            $rslt[] = $row;
        }

        return $rslt;
    }

    function installed_themes_missing_directories()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select cpt.ptName, cpt.ptHandle, cpt.ptDescription, cpt.pkgHandle, cpt.isSiteTheme ' .
            ' from CobblePageThemes cpt ' .
            ' where cpt.ptDirectory is NULL ' .
            ' order by cpt.ptName ';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            extract($row);
            $row['isSiteTheme'] = $this->b2t($isSiteTheme);
            $row['pkgHandle'] = $this->null2na($pkgHandle);
            $rslt[] = $row;
        }

        return $rslt;
    }

    function page_types_missing_templates()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select cpt.ptName, ct.ctName, cct.ctHandle, cct.pkgHandle ' .
            ' from (CobblePageTypes cct left join PageTypes ct on cct.ctID = ct.ctID) ' .
            ' left join CobblePageThemes cpt on cct.cblPtID = cpt.cblPtID ' .
            ' where cct.filePath is null ' .
            ' order by ptName, ctName ';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            extract($row);
            $row['pkgHandle'] = $this->null2na($pkgHandle);
            $row['ptName'] = $this->null2msg($ptName, 'THEME-INDEPENDENT');
            $rslt[] = $row;
        }

        return $rslt;
    }

    function theme_independent_page_types_missing_wrappers()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select ct.ctName, cct.ctHandle, cct.pkgHandle ' .
            ' from (CobblePageTypes cct left join PageTypes ct on cct.ctID = ct.ctID) ' .
            ' left join CobblePageThemes cpt on cct.cblPtID = cpt.cblPtID ' .
            ' where cct.wrapperPath is null ' .
            ' and cpt.ptName is null ' .
            ' order by ctName ';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            extract($row);
            $row['pkgHandle'] = $this->null2na($pkgHandle);
            $rslt[] = $row;
        }

        return $rslt;
    }

    function page_type_sp_conflict()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select cpt.ptName, ct.ctName, cct.ctHandle, cct.ctFilePrefix, cct.filePath, cct.wrapperPath, cct.pkgHandle' .
            ' from (CobblePageTypes cct left join PageTypes ct on cct.ctID = ct.ctID) ' .
            ' left join CobblePageThemes cpt on cct.cblPtID = cpt.cblPtID ' .
            ' left join CobblePages cp on cct.ctHandle = cp.cHandle ' .
            ' where (cct.isSinglePageHandle = 1 and cp.cHandle is not NULL and cp.isThemeFromPath = 0) ' .
            ' order by ptName, ctName ';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            extract($row);
            $row['wrapperPath'] = $this->null2na($wrapperPath);
            $row['pkgHandle'] = $this->null2na($pkgHandle);
            $row['ptName'] = $this->null2msg($ptName, 'THEME-INDEPENDENT');
            $row['ctFilePrefix'] = $this->null2msg($ctFilePrefix, 'TEMPLATE MISSING!');
            $row['filePath'] = $this->null2msg($filePath, 'TEMPLATE MISSING!');
            $rslt[] = $row;
        }

        return $rslt;
    }

    function unregistered_single_pages()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select cp.cFilename, cp.cHandle, cp.filePath ' .
            ' from CobblePages cp left join PageTypes ct on cp.ctID = ct.ctID ' .
            ' where cp.cID is null ';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            $rslt[] = $row;
        }

        return $rslt;
    }

    function pages_missing_file()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select cp.cID, cp.cFilename, cp.cHandle, cp.wrapperPath ' .
            ' from CobblePages cp ' .
            ' where cp.isFileMissing = 1';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            $rslt[] = $row;
        }

        return $rslt;
    }

    function single_pages_missing_wrapper()
    {
        $db = Loader::db();
        $rslt = array();
        $q = 'select cp.cID, cp.cFilename, cp.cHandle, cp.filePath ' .
            ' from CobblePages cp ' .
            ' where cp.isWrapperMissing = 1';
        $r = $db->query($q);
        while ($row = $r->fetchRow()) {
            $rslt[] = $row;
        }

        return $rslt;
    }


    /****************************************************/
    /*               HELPERS                            */
    /****************************************************/
    function b2t($val)
    {
        return $val == 1 ? 'Yes' : 'No';
    }

    function null2na($val)
    {
        return isset($val) ? $val : 'N/A';
    }

    function null2msg($val, $msg)
    {
        return isset($val) ? $val : $msg;
    }

}

